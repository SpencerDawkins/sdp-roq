{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-02-16T01:08:14.944972+00:00",
  "repo": "ietf-wg-avtcore/sdp-roq",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMBStD86K88gs",
      "title": "Consider including a=fingerprint mechanism in a p2p SDP example",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/1",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @juberti on AVTCORE mailing list: \r\n\r\n> For c2s use, the SDP you have outlined should work well. For p2p usage, we should include the a=fingerprint mechanism used in https://datatracker.ietf.org/doc/html/rfc5763 to allow validation of self-signed peer certs.",
      "createdAt": "2022-02-05T00:23:54Z",
      "updatedAt": "2024-06-03T13:57:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOMBStD86K89Qa",
      "title": "Consider including a=tls-id in SDP",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/2",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @juberti, on the AVTCORE mailing list: \r\n\r\n> It would probably be a good idea for the SDP to include a=tls-id, defined in https://datatracker.ietf.org/doc/html/rfc8842, to ensure endpoints can tell when the security handshake is being restarted, as discussed in the cited RFC. This would probably obivate the need for a=connection:new as well (which is not typically used in DTLS-SRTP).",
      "createdAt": "2022-02-05T00:21:13Z",
      "updatedAt": "2024-06-03T13:58:17Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOMBStD86K89jJ",
      "title": "Check QUIC impacts on BUNDLE",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/3",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @cdh4u - Please remember to check whether there are any BUNDLE impacts. Section 9 of BUNDLE contains RTP considerations for BUNDLE, so I suggest to check whether there is anything that needs to be updated/modified for QUIC usage.",
      "createdAt": "2022-01-30T00:48:23Z",
      "updatedAt": "2024-06-03T13:58:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOMBStD86LNHmm",
      "title": "Proposal for identifying RoQ Flow IDs",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/4",
      "state": "OPEN",
      "author": "samhurst",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've been separately experimenting with describing RoQ sessions in an implementation of my [old SIP-over-QUIC draft](https://datatracker.ietf.org/doc/draft-hurst-sip-quic/), which uses SDP offer/answer underneath.\r\n\r\nI've been prodding at this for a while and gone through a few iterations, and what I've landed on is adding a new attribute that describes the RoQ Flow Identifier.\r\n\r\nLooking at the prior-art in this area, I've found [DCCP-UDP](https://datatracker.ietf.org/doc/html/rfc6773) and [SCTP-DTLS](https://datatracker.ietf.org/doc/html/rfc8841). In both of these cases, the transport protocol carrying the RTP (DCCP and SCTP) are encapsulated in another protocol (UDP and UDP/DTLS or TCP/DTLS respectively). This is the same as RoQ - this is RTP being encapsulated in QUIC transport, therefore I think this is the right way to do it.\r\n\r\nTaking DCCP as one example, the port of the encapsulating UDP packet goes in the media (\"m=\") line, and then the DCCP port number does in a [`dccp-port` attribute](https://datatracker.ietf.org/doc/html/rfc6773#section-5.2). This spec also specifies what to do with a media description that contains the `rtcp` or `rtcp-mux` attributes.\r\n\r\nTherefore, for RoQ the UDP port for the QUIC transport connection goes into the media (\"m=\") line, and then we have to describe the Flow Identifier in an attribute, which I've called `roq-flow-id`. The RoQ-SDP spec should probably mention the specifics about mapping RoQ Flow Identifiers onto the `rtcp` attribute as well. The concern here should be that some parsers will assume that the `rtcp` attribute will contain a value only between 1 and 65535 (i.e. a 16-bit unsigned integer), whereas an RTP Flow Identifier is defined as a 62-bit unsigned (variable length QUIC) integer. The ABNF for the `port` attribute is `1*(DIGIT)`, so in theory it should be fine as the limit is only given in a comment, but an implementer-beware message should suffice here I think.\r\n\r\nHere's an example SDP offer from my implementation:\r\n\r\n```o=samuelh 34178951687 34178951687 IN IP4 10.44.0.77:43243\r\ns= \r\ni=SIP-over-QUIC Offer/Answer example\r\nc=IN IP4 10.44.0.77:43243\r\nt=0 0\r\nm=video 43243 QUIC/RTP/AVPF 96\r\na=roq-flow-id:0\r\na=rtcp:1\r\na=rtpmap:96 H264/90000\r\na=fmtp:96 profile-level-id=640020;packetization-mode=1;sprop-parameter-sets=Z0LAHtkAyD2wFqDAwNS\r\na=imageattr:96 send [x=1280,y=720,sar=1.0]\r\na=sendonly\r\nb=AS:5000\r\n```\r\n\r\nLet me know what you think. I can try and come up with a pull request with some text to go into the draft for this if you'd like.",
      "createdAt": "2024-06-05T10:08:40Z",
      "updatedAt": "2024-11-25T13:29:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @samhurst, what you're proposing here makes perfect sense to me. If you have a moment to propose text, that would be great!\r\n\r\nI do have questions (and will probably have more after I get home from IETF 120), but one obvious question is that Bernard has asked interesting questions in the [RoQ repository](https://github.com/mengelbart/rtp-over-quic-draft/issues/226) about whether we should be (strongly) recommending datagrams for RTCP in RoQ implementations. Mathis has a proposal on the AVTCORE mailing list about that [here](https://mailarchive.ietf.org/arch/msg/avt/x8RW0j6m7NiuSXXtSgWgbFhZNsw/), with pointers to the PR, diffs, etc. \r\n\r\nI don't know whether that possibility would affect any text you provide, but I wanted to make sure you knew what I know. ",
          "createdAt": "2024-07-27T00:38:54Z",
          "updatedAt": "2024-07-27T00:38:54Z"
        },
        {
          "author": "rjb1000",
          "authorAssociation": "NONE",
          "body": "> I do have questions (and will probably have more after I get home from IETF 120), but one obvious question is that Bernard has asked interesting questions in the [RoQ repository](https://github.com/mengelbart/rtp-over-quic-draft/issues/226) about whether we should be (strongly) recommending datagrams for RTCP in RoQ implementations. Mathis has a proposal on the AVTCORE mailing list about that [here](https://mailarchive.ietf.org/arch/msg/avt/x8RW0j6m7NiuSXXtSgWgbFhZNsw/), with pointers to the PR, diffs, etc.\r\n\r\nLooking at the analysis on [RoQ issue #226](https://github.com/mengelbart/rtp-over-quic-draft/issues/226), the existence of RFC 4571 makes it difficult to be prescriptive about using QUIC datagrams to convey RTCP packets. Conveying RTCP over a reliable connection is just a fact on the ground that needs to be accommodated in the RoQ specification. I think that @mengelbart has found a suitably neutral path in his proposed change to the RoQ I-D. The recommendation there not to mix and match streams and datagrams for RTP and RTCP traffic in the same QUIC connection seems sensibly pragmatic too.\r\n\r\nPresumably it is useful to be able to discriminate between datagram carriage and reliable stream carriage of RoQ in the SDP offer/answer. The vocabulary of Media Description *proto* identifiers could enforce the recommendation against mixing and matching for RTP and RTCP.\r\n\r\nOne additional question in my mind: I wonder if the combination in the same QUIC connection of RTP and RTCP conveyed in datagrams plus SIP carried over reliable streams would disrupt RTCP's measurement of round-trip time? Looking at @mengelbart's proposal, I presume not since it effectively redefines RTT as a measure of the application layer outcome for the RTCP packets, independent of how they are conveyed in the QUIC connection, instead of being a network layer metric.",
          "createdAt": "2024-07-30T11:17:24Z",
          "updatedAt": "2024-07-30T11:17:24Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@samhurst, I think that this proposal is quite helpful. I think your example, plus the way we are talking about handling streams vs dgrams vs streams-and-dgrams in #6, translates into a pretty complete example SDP offer. \r\n\r\nI've asked @menglebart about one other thing - whether we need an RoQ Session - we use that term ONCE in https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-terminology-and-notation, and (embarrassingly) never define it. If we can introduce this concept (as basically \"this is all the media that I will be sending you, that's intended to be handled as a group(?)/bundle(??), no matter what QUIC connection it arrives on\"), it would be helpful to signal a RoQ Session ID, with all RoQ Flow IDs scoped to the RoQ Session ID. \r\n\r\nI'll be typing text about this, but I'm just reminding all of us that we have a bit more to discuss, and if we're introducing concepts and constraints in the RoQ specification, we need to at least give the working group a heads-up, because this is a working group draft. ",
          "createdAt": "2024-11-11T13:02:39Z",
          "updatedAt": "2024-11-11T13:02:39Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "NONE",
          "body": "`a=roq-flow-id:<id>` sounds good to me. We might need to make sure that RTP and RTCP can be distinguished, though (maybe use different attribute names?).\r\n\r\nI'm not sure why we need another RoQ session ID.\r\n\r\n@rjb1000 \r\n> One additional question in my mind: I wonder if the combination in the same QUIC connection of RTP and RTCP conveyed in datagrams plus SIP carried over reliable streams would disrupt RTCP's measurement of round-trip time?\r\n\r\nMultiplexing multiple protocols with RTP/RTCP is not supported by RoQ but could be added if you define a new ALPN. When you do this, depending on how much data the other protocol is sending, RTT could be disrupted, either on the QUIC layer or on the application layer, or both. QUIC and RTCP on the application layer might not agree on RTT, also when only RTP is used, due to queuing within the QUIC stack.",
          "createdAt": "2024-11-11T19:42:18Z",
          "updatedAt": "2024-11-11T19:42:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure why we need another RoQ session ID.\r\n\r\nI'm probably not explaining this clearly, but I don't think we have a RoQ session ID at all. :grin:\r\n\r\nLet's make believe that I'm sending you two audio streams (left and right) for a single video stream. I think all of those have different flow identifiers - they just happen to be in the same QUIC connection. \r\n\r\nI don't think we have an identifier that describes that **set** of flows, **as a set**. Do you think we have one?\r\n\r\nIf we agree on whether we already have one, we can talk about whether we need one!",
          "createdAt": "2024-11-18T01:58:35Z",
          "updatedAt": "2024-11-18T01:58:35Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "I think RTP already has mechanisms that we can utilise for this, and it's not something RoQ needs to be bothering with. RoQ is just the framing mechanism between a pair of peers, my understanding is that RoQ does not (and my strong opinion is that it **should not**) imply any equivalency between RTP media sessions and QUIC/RoQ sessions. I actually had an [explicit section describing this in my previous QRT draft](https://datatracker.ietf.org/doc/html/draft-hurst-quic-rtp-tunnelling-01#section-3).\r\n\r\nI think the closest I can think of for @SpencerDawkins 's **set** idea are the [Media Stream Identification](https://www.rfc-editor.org/rfc/rfc3388#section-3) and [Group](https://www.rfc-editor.org/rfc/rfc3388#section-4) attributes.\r\n\r\nAs a side note for @mengelbart - I just reviewed [rtp-over-quic-12](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-12.html) while tying this response and found a couple of references to a \"RoQ (media) session\" which might be worthwhile defining or removing - your choice.",
          "createdAt": "2024-11-19T15:47:05Z",
          "updatedAt": "2024-11-19T15:47:05Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think RTP already has mechanisms that we can utilise for this, and it's not something RoQ needs to be bothering with. RoQ is just the framing mechanism between a pair of peers, my understanding is that RoQ does not (and my strong opinion is that it **should not**) imply any equivalency between RTP media sessions and QUIC/RoQ sessions. I actually had an [explicit section describing this in my previous QRT draft](https://datatracker.ietf.org/doc/html/draft-hurst-quic-rtp-tunnelling-01#section-3).\r\n> \r\n> I think the closest I can think of for @SpencerDawkins 's **set** idea are the [Media Stream Identification](https://www.rfc-editor.org/rfc/rfc3388#section-3) and [Group](https://www.rfc-editor.org/rfc/rfc3388#section-4) attributes.\r\n\r\n@samhurst - I was wondering about that myself - thank you for nudging me in that direction!\r\n\r\n> As a side note for @mengelbart - I just reviewed [rtp-over-quic-12](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-12.html) while tying this response and found a couple of references to a \"RoQ (media) session\" which might be worthwhile defining or removing - your choice.\r\n\r\nMy suggestion was to define it, especially if we can define it using existing RTP mechanisms. We seemed to fall into that term naturally. But I can talk with @mengelbart about that more. \r\n\r\n",
          "createdAt": "2024-11-25T13:29:51Z",
          "updatedAt": "2024-11-25T13:29:51Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOMBStD86LNSAO",
      "title": "How to identify QUIC transport sessions",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/5",
      "state": "OPEN",
      "author": "samhurst",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft currently doesn't specify how to identify a QUIC transport session that will carry the RTP-over-QUIC traffic. I think we could adopt the COMEDIA mechanisms specified for TCP and adapt them to QUIC. [RFC4145](https://www.rfc-editor.org/rfc/rfc4145) specifies how to do it with regular TCP and section 8 describes how to apply it to protocols that are not TCP. Then there's [RFC8122](https://www.rfc-editor.org/rfc/rfc8122) which adds things about TLS (which I haven't read in detail yet so I don't know if this is helpful, but I'm linking it here anyway just in case).\r\n\r\nThe only concern I have is that existing COMEDIA options all use the 5-tuple to uniquely identify a transport connection. However, a QUIC connection is not bound to a single 5-tuple, as it can perform connection migration. In future, this would also preclude the description of multipath QUIC sessions.\r\n\r\nIn the case where a new connection is established, this should be fine - but the concern here is about reuse of existing connections. Given that QUIC allows multiplexing of traffic, there's definitely a use-case where you could negotiate SDP media descriptions using something like SIP-over-QUIC using bidirectional streams, and then re-use the same transport connection with the callee/caller to run the RTP over unidirectional streams.\r\n\r\nI don't have a good answer to the identification of extant QUIC transport associations at the moment, so this is more of an open question. We also can't use QUIC connection IDs as for one they can be generated and revoked at any time by the transport layer, and two I feel that putting connection IDs in an SDP media description is a security problem as it means an attacker could gain prior knowledge of some of the things which might be present in a QUIC transport packet, and use that to help attack the encryption context.",
      "createdAt": "2024-06-05T10:27:53Z",
      "updatedAt": "2024-11-13T12:14:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, the last time you and I talked about flow IDs, we said they were scoped to a QUIC connection, is that right? \r\n\r\nIn order to address @samhurst's question, it looks to me like \r\n\r\n- including QUIC connections in the SDP is not a good idea, \r\n- but we need some kind of identifier that tells the answerer side of SDP that two different QUIC connections are related, unless we are punting both QUIC connection migration and QUIC multipath. \r\n\r\nIf Flow IDs are scoped to a \"RoQ Session\", which could span QUIC connections, we can include Flow IDs in the SDP and solve this problem, but \"RoQ session\" is an undefined term which is used exactly once in the RoQ specification. Do you have any thoughts about this, or should I just create an issue in https://github.com/mengelbart/rtp-over-quic-draft?",
          "createdAt": "2024-11-11T12:34:25Z",
          "updatedAt": "2024-11-11T12:34:25Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "NONE",
          "body": "I don't think using flow IDs to identify QUIC connections is a good solution for this problem. It requires reading the payload of at least one RTP/RTCP packet but doesn't allow the endpoint to identify the QUIC connection based on the handshake packets.\r\n\r\nThis is a hard problem, and I am not sure how we can solve it. In addition to connections changing their 5-tuple, I think we could also have multiple connections with the same 5-tuple, which doesn't make it easier...\r\n\r\nHowever, I wouldn't rule out connection IDs completely. Maybe we can't put explicit IDs in SDP directly, but maybe there's a way along the lines of what the [QUIC LB draft](https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers) is doing by encoding some information in the connection ID?",
          "createdAt": "2024-11-11T19:27:03Z",
          "updatedAt": "2024-11-11T19:27:03Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "It is a very hard problem indeed, as we're trying to do something that QUIC was expressly designed to avoid. I still think that adopting the COMEDIA approach to specify new/existing connections is required, and it's always an option to be more prescriptive than the QUIC spec allows - for example, it could be written that we can't reuse QUIC connections that are multiplexed on the same 5-tuple. The SDP answerer would be expected to change the connection attribute to \"new\" if this condition cannot be met, as specified in [section 5.1 of RFC 4145](https://www.rfc-editor.org/rfc/rfc4145#section-5.1).\r\n\r\nI think it's also worth thinking about whether we want to consider the capabilities of extant QUIC connections to slim down the pool of potential reuse candidates. For example, if you've got three QUIC connections to choose from, you could look at the negotiated ALPNs for those connections and decide whether they would be compatible. For example, any `h3` ones wouldn't be compatible, but any with `roq` would be. Equally, any other ALPNs that include scope for carrying RoQ frames (such as SIP-over-QUIC, which may be the same connection exchanging these SDP documents) could be considered.\r\n\r\nI'm not sure the QUIC-LB approach would really work here, as it will make a lot of assumptions on how QUIC stacks work. The connection would need to support it right from the beginning, and if the connection is owned by something like a web browser I don't know what level of imposition we can realistically make on how they generate connection IDs. And indeed, it implies a much tighter bindings to the internals of a QUIC connection than realistically RoQ or SDP needs to have.\r\n\r\nI have also tried looking for other attributes or features that already exist in QUIC that we could use, and I'm coming up a bit short. We could reuse the token which is exchanged by `NEW_TOKEN` frames, but this is used to validate connection paths so this would be information leakage that an attacker could exploit to make the QUIC stack do something odd, same as disclosing connection IDs. The only other option I've come up with is to invent a new transport parameter that just stores a random value which is otherwise never shared between endpoints as a way of identifying QUIC connections out-of-band, but again this requires more fiddling deeper in the QUIC stack.",
          "createdAt": "2024-11-13T12:14:55Z",
          "updatedAt": "2024-11-13T12:14:55Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOMBStD86LNdkv",
      "title": "How to describe whether data will be sent over streams or datagrams",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/6",
      "state": "OPEN",
      "author": "samhurst",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, there's no specified way for a a media description to describe how RTP and RTCP data is transmitted, either over QUIC streams or DATAGRAM frames.\r\n\r\nI seem to remember in the past that putting `stream` or `dgram` in the proto field of the media line (i.e. `QUIC/stream/RTP/AVP`), which I've been experimenting with but I don't think this is quite right.\r\n\r\nThe latest RoQ draft specifies that [RTP can be sent on streams, DATAGRAM frames or a mixture of both](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-10.html#name-rtp-with-quic-streams-quic-). With my implementer hat on, here's some use-cases that I can think of where I might want to do different things:\r\n\r\n- Send one RTP session over streams, and another over DATAGRAM frames (i.e. a more important stream that I'm less tolerant of loss on against something I don't mind loss on)\r\n- Within a single RTP session, sending all RTP over streams and all RTCP over DATAGRAM frames.\r\n- Within a single RTP session that in this case is sending a video stream, sending all RTP packets containing I-frames over streams for reliability, and then B- and P-frames over DATAGRAM frames.\r\n\r\nI'm sure there are potentially other use-cases, but these are the ones that I can think of so far.\r\n\r\nNow, looking at QUIC transport itself, DATAGRAM frames are an extension that may not be available. So a soft-touch approach to this might be that the SDP media description simply states that the QUIC connection should be negotiated with support for DATAGRAM frames, and then leave the actual usage up to the implementations.\r\n\r\nOtherwise, might there be a reason why we want to describe how streams/datagrams will be used in a given media session? Maybe an implementation doesn't want to have too much DATAGRAM processing to do, so it could reject an offer that includes lots of DATAGRAM usage. I don't have a good answer to this one either, so I'll leave this as an open question too.",
      "createdAt": "2024-06-05T10:48:09Z",
      "updatedAt": "2024-11-13T12:28:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @samhurst, thank you for raising this issue, which has been in suspended animation for far too long! I had expected to use stream and dgram in the SDP proto field, but we haven't seriously talked about that since @mengelbart and I started seriously looking at this question in the RoQ draft. \r\n\r\nAssuming (and I think we have to assume this) that we are including a RoQ Flow ID in the SDP, as we are discussing in #5, would this simply be that we have two m-lines with the same transport IDs and Flow IDs, but different protos (one something like QUIC/stream/RTP/AVP, and the other like QUIC/dgram/RTP/AVP)?\r\n\r\nObviously I need to read more about this, but that's what I think you're suggesting!",
          "createdAt": "2024-11-11T12:05:37Z",
          "updatedAt": "2024-11-11T12:07:20Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "Did you mean issue #4 not #5 ? Although #5 is related as that is asking the question about how to identify a QUIC connection, presumably what you mean by \"transport ID\".\r\n\r\nSince writing this issue a few months ago, I've been using an additional attribute in the media session to signal whether datagrams are required for this media session, something like this:\r\n\r\n```\r\nm=video 37984 QUIC/RTP/AVPF 96\r\na=roq-flow-id:0\r\na=quic-datagrams\r\n(...)\r\n```\r\n\r\nThis was my initial thought, but I actually like what you're proposing too. If we had two media sessions, each identical with the exception of the `proto` field, then there's a mechanism for the SDP Offer/Answer to reject an offer that requires datagram support if the endpoint doesn't support it. Thus:\r\n\r\nOffer:\r\n```\r\nm=video 37984 QUIC/stream/RTP/AVPF 96\r\na=roq-flow-id:0\r\n(...)\r\nm=video 37984 QUIC/dgram/RTP/AVPF 96\r\na=roq-flow-id:0\r\n(...)\r\n```\r\n\r\nAnswer:\r\n```\r\nm=video 37984 QUIC/stream/RTP/AVPF 96\r\na=roq-flow-id:0\r\n(...)\r\nm=video 0 QUIC/dgram/RTP/AVPF 96\r\na=roq-flow-id:0\r\n(...)\r\n```\r\n\r\nErgo, no datagrams. What do you think?",
          "createdAt": "2024-11-11T12:32:19Z",
          "updatedAt": "2024-11-11T12:32:19Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@samhurst, I like that you were digging in a different hole nearby, in the same field. I think that's a way for us to handle \"you can expect anything to arrive in either a stream or a datagram, and if you know what you're doing, maybe both\", and allows someone to say \"but I don't support datagrams - so just send me streams\". \r\n\r\nI'm ready call this converged!\r\n\r\n(you're right, we're discussing related ideas and requirements in multiple issues, which is way better than discussing them in multiple PRs!)",
          "createdAt": "2024-11-11T12:42:35Z",
          "updatedAt": "2024-11-11T12:42:35Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "I think I'd need to go and re-read the SDP specs to convince myself that we can advertise multiple parts of the same stream under different media lines, as I'm certainly no expert here.\r\n\r\nThe only drawback I can think of now is where an SDP offer only includes a media description with the `dgram` protocol and no `stream`s, if the SDP answerer doesn't support datagrams then there's no easy fallback to just using streams. But is this really an issue?",
          "createdAt": "2024-11-11T15:37:35Z",
          "updatedAt": "2024-11-11T15:37:35Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "NONE",
          "body": "I wonder if we need to signal this in SDP at all. As @samhurst mentioned in the first comment, there are use cases for mixing streams and datagrams. RoQ has an error code for cases where external signaling does not agree with the parameters negotiated during QUIC connection establishment, but it would be nice if we could completely avoid that error condition. Datagrams are declared unilaterally, so if an application is ready to accept RTP over QUIC datagrams, it has to announce support for datagrams. If it does not want to receive datagrams, it shouldn't declare support for it. Similarly, if an application does not want to receive RTP in QUIC streams, it can use stream flow control to prohibit the peer from opening new streams.\r\n\r\nI am not an SDP expert, but if there is a good reason to include a signal in SDP, using `a=quic-datagrams` looks cleaner to me than including it in multiple `m` lines. One could also add different combinations if that would be useful, e.g., to allow mixing.",
          "createdAt": "2024-11-11T18:57:10Z",
          "updatedAt": "2024-11-11T18:57:10Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "I don't quite know how RoQ \"announces\" support for datagrams. Is it not more that if support for sending RoQ datagrams is implied if the transport has exchanged `max_datagram_frame_size` transport parameters with a non-zero size?\r\n\r\nIt's also not really unilateral, as each endpoint in a QUIC connection can specify different values for the `max_datagram_frame_size` transport parameter, leading to only one endpoint being able to transmit datagrams. I think it does need to be negotiated in SDP, because the transport parameter says what the given endpoint is willing to receive. So in the case where the endpoint that creates the SDP wants to be able to use datagrams to send media, it needs to tell the remote endpoint to set the `max_datagram_frame_size` transport parameter to an appropriate value.\r\n\r\nI do agree that the `a=quic-datagrams` attribute is cleaner, and when combined with the direction attributes would give a set of rules for an endpoint when opening a new QUIC connection for that media session.",
          "createdAt": "2024-11-13T12:27:58Z",
          "updatedAt": "2024-11-13T12:27:58Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOMBStD86LNkRO",
      "title": "Controlling stream representation",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/7",
      "state": "OPEN",
      "author": "samhurst",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is related to my questions in #6, but this is something I've been experimenting on so wanted to surface it somewhere, and as this may result in some suggestions that go back to the RoQ draft itself I thought I won't detract from discussion there with this.\r\n\r\nIn my implementation, I've made it so the way that RTP frames are payloaded into QUIC streams can be controlled in the following ways:\r\n\r\n- All RTP frames on a single stream (until the QUIC stream runs out of sending credit)\r\n- All RTP frames for one or more GOPs on a single stream\r\n- All RTP frames for one or more frames on a single stream\r\n\r\nI control this with a \"stream boundary\" and \"stream packing\" parameter. The \"stream boundary\" parameter can be set to single, gop or frame, and then the \"stream packing\" parameter sets the number of GOPs or frames to put in each stream.\r\n\r\nThe reason you might want to do this is to be able to send `STOP_SENDING` or reset a stream you're no longer interested in, to get the sender to catch up to the latest frames.\r\n\r\nThe RoQ draft doesn't say anything on this subject, merely leaves it up to implementations to decide. I wonder whether this is something that we might want to specify more concretely, and where would be the best place to put it? Is there a use-case for a caller requesting a stream (i.e. `a=recvonly`) and then specifying how it wants that stream to be delivered? I've added `roq-stream-boundary` and `roq-stream-packing` attributes to my WIP implementation and have been experimenting with it a little bit with the intention of seeing whether it can positively affect latency on received streams.",
      "createdAt": "2024-06-05T11:01:20Z",
      "updatedAt": "2024-11-11T19:13:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@samhurst - I THINK [Section 5.2.2 of the current RoQ specification](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-media-frame-cancellation) addresses the way a receiver can get the sender to catch up to the current media frames. Does it look that way to you? ",
          "createdAt": "2024-10-28T13:42:22Z",
          "updatedAt": "2024-10-28T13:42:22Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "Hi @SpencerDawkins ,\r\n\r\nSection 5.2.2 certainly describes the mechanism for the receiver to stop the reception of frames on individual streams, and it's up to the sender to decide what that means, as the wording of 5.2.2 is not prescriptive over what the intended response by the sender should be in this instance. The only prescriptive part of it is that any media frame already sent on the QUIC stream that the receiver has stopped reading can't be sent again.\r\n\r\nHowever, my question is more to do with controlling how the sender chooses to use streams to present RTP frames to the receiver, not in response to the receiver requesting that a given stream stops sending, although there is some overlap. Section 5.2 of the RoQ draft describes that RoQ senders may choose to do this to avoid head-of-line blocking. What I'm seeking to achieve here is how do we describe this behaviour in SDP?",
          "createdAt": "2024-10-28T16:07:37Z",
          "updatedAt": "2024-10-28T16:07:37Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @samhurst, so, is the idea that the sender is telling the receiver what to expect, or that the receiver is telling the sender what to do? \r\n\r\n- If the sender is telling the receiver what to expect, that seems like a local decision at the sender (I know what is best for you). That might be more appropriate in RoQ, to make sure that receivers can handle reasonable sender behaviors. If that's what we're talking about, maybe we don't need to describe it in SDP. \r\n- if the receiver is telling the sender what to do, that absolutely needs to be in SDP, but I suspect that the behavior also needs to be in the RoQ draft. \r\n\r\nAm I following you closely enough? \r\n\r\n@mengelbart, do you have thoughts about this? ",
          "createdAt": "2024-11-11T11:52:46Z",
          "updatedAt": "2024-11-11T11:52:46Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "In a SIP/SDP Offer/Answer world, the caller and callee don't necessarily map to sender and receiver of media. In the case where the media sender is also creating an SDP document (i.e. SIP caller or SIP callee creating a negotiated SDP document), I agree that it's probably not required to describe the media representation but I don't see the harm in including it. I can see a use case where the SDP will result in a new QUIC connection, you could use this information to help drive transport parameters. For example, for a sender sending on a single stream, it's peer could negotiate a very large `initial_max_stream_data_uni` transport parameter.\r\n\r\nThese are implementation decisions, so I don't think they should be in the RoQ draft which mostly deals with how RTP messages are carried on QUIC transport. RoQ doesn't have any real way of negotiating or signalling this kind of thing, and I would argue that it doesn't need it anyway, but I'm interested in what other people think.",
          "createdAt": "2024-11-11T12:08:48Z",
          "updatedAt": "2024-11-11T12:08:48Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "NONE",
          "body": "I agree that RoQ doesn't need to signal this, but there may be cases where it could be useful for a receiver to know what to expect in order to provide sufficient flow control limits. `initial_max_stream_data_uni` is one example, `initial_max_streams_uni` is another example, which may be particularly important in large sessions with many streams where each frame opens a new stream.\r\n\r\nI am not sure if this needs to be negotiated in SDP, though. I think in most cases, the sender will be in a better position to decide whether to open new streams or not and receivers should be prepared for that by providing enough flow control credits to allow the sender to do the right thing.",
          "createdAt": "2024-11-11T19:13:50Z",
          "updatedAt": "2024-11-11T19:13:50Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMBStD86QRr0F",
      "title": "Align RoQ and SDP-RoQ drafts (in SDP-RoQ)",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/issues/8",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This issue is the counterpart to Issue [224](https://github.com/mengelbart/rtp-over-quic-draft/issues/224) in the[rtp-over-quic-draft](https://github.com/mengelbart/rtp-over-quic-draft/) Github repo. \r\n\r\nFor background, see [the June 2024 AVTCORE virtual interim meeting notes](https://notes.ietf.org/notes-ietf-interim-2024-avtcore-02-avtcore?edit) for both [RoQ](https://youtu.be/9K6lLFngMYM?si=sskgPTM4fLVC_Pdn&t=1712) and [SDP-RoQ](https://youtu.be/9K6lLFngMYM?si=TI0iJWv7RRcvvarq&t=3246) sessions. \r\n\r\nThis issue is intended to capture what is not part of the current RoQ specification, and is not specifically tied to SDP for RoQ. \r\n\r\nAs a starting point, this would include options for opening, and for reusing, a QUIC connection for RoQ.\r\n\r\nThese options include (at least) \r\n\r\n- manual configuration of an endpoint, \r\n- reuse of a QUIC connection that was used for SDP, \r\n- use of the \"roq\" APLN defined in the RoQ specification, and \r\n- using SDP to open and reuse a QUIC connection, similarly to the way RTP over TCP uses SDP to open and reuse TCP connections. \r\n\r\nThis issue will likely grow before it shrinks!",
      "createdAt": "2024-07-20T04:31:45Z",
      "updatedAt": "2024-07-20T04:31:46Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOMBStD86EKc_4",
      "title": "Add roq-flow-id attribute (Fixes #4)",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/9",
      "state": "OPEN",
      "author": "samhurst",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This change defines the roq-flow-id attribute, as discussed on issue #4.",
      "createdAt": "2024-12-05T10:39:36Z",
      "updatedAt": "2024-12-16T00:15:38Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "8a121fd732cb4d2e555b84a833c7641d58a9f729",
      "headRepository": "samhurst/sdp-roq",
      "headRefName": "roq-flow-ids-4",
      "headRefOid": "fa92df7935889f51af5134a8d5951cc145de0c53",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMBStD86VTXBr",
          "commit": {
            "abbreviatedOid": "fa92df7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@samhurst , I've been working on a private copy of the draft for a while, without committing the draft in GitHub (my mistake), but your proposed text \r\n\r\n- looks fine to me, and \r\n- is sufficiently modular that I was able to include it in my private copy. \r\n\r\nI'm marking this as approved in GitHub, and your proposed text should appear in my next commit. \r\n\r\n@victorpascualavila and I appreciate your support a great deal!",
          "createdAt": "2024-12-16T00:15:38Z",
          "updatedAt": "2024-12-16T00:15:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOMBStD86FSgJP",
      "title": "Update draft-dawkins-avtcore-sdp-roq.md",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/10",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This is a significant change to the main branch - I'm leaving it as a PR for now.",
      "createdAt": "2024-12-16T02:06:07Z",
      "updatedAt": "2025-02-06T21:34:35Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "8a121fd732cb4d2e555b84a833c7641d58a9f729",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "large-change",
      "headRefOid": "cb9b8e933d32adcc5fa799d66f976cc1d94959e7",
      "closedAt": "2025-02-02T18:25:05Z",
      "mergedAt": "2025-02-02T18:25:05Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "aa1d62f3c6575196e0b5475bffdbc0c58467be27"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOMBStD86KCFmh",
      "title": "Corrections in SDP example, subsections in existing SDP extensions section",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/11",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-04T17:49:19Z",
      "updatedAt": "2025-02-06T21:34:32Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "aa1d62f3c6575196e0b5475bffdbc0c58467be27",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "update-example",
      "headRefOid": "9b3e7f6cb774c8e1a9d874b4c59095781d035229",
      "closedAt": "2025-02-06T17:54:38Z",
      "mergedAt": "2025-02-06T17:54:38Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "25ed7d4a55c1e299936a43c5deddc6796357cef3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOMBStD86KVSKV",
      "title": "Synchronize questions from draft and interim presentation",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/12",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-06T20:41:40Z",
      "updatedAt": "2025-02-06T21:34:30Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "25ed7d4a55c1e299936a43c5deddc6796357cef3",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "questions",
      "headRefOid": "1b7aeedb6096f2ee1aa70a68554a65f67e016052",
      "closedAt": "2025-02-06T21:06:15Z",
      "mergedAt": "2025-02-06T21:06:15Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "e0236a37d13035f8588b83f21791a705ddb57144"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMBStD86a97Oo",
          "commit": {
            "abbreviatedOid": "5d65766"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-06T21:02:46Z",
          "updatedAt": "2025-02-06T21:02:47Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nWe have two goals for this section:\r\n```",
              "createdAt": "2025-02-06T21:02:46Z",
              "updatedAt": "2025-02-06T21:02:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOMBStD86KVmUU",
      "title": "Move to new home in the draft",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/13",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-06T21:20:32Z",
      "updatedAt": "2025-02-06T21:23:19Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "e0236a37d13035f8588b83f21791a705ddb57144",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "move-to-new-home",
      "headRefOid": "c1b5f6aab6023a1563fb049251c26e4b0ab55128",
      "closedAt": "2025-02-06T21:23:19Z",
      "mergedAt": "2025-02-06T21:23:19Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "10dba9607d83510c60f04163e721b5e95faf8072"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOMBStD86KVtS_",
      "title": "Update the README",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/14",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-06T21:32:19Z",
      "updatedAt": "2025-02-06T21:34:12Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "10dba9607d83510c60f04163e721b5e95faf8072",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "move-to-new-home",
      "headRefOid": "5b47c483bccdcf92e4ab76c4e650fef6d8f9eca2",
      "closedAt": "2025-02-06T21:32:30Z",
      "mergedAt": "2025-02-06T21:32:30Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "ac66462fbfbaeba3a662927e5a23806378d5fd7a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOMBStD86KVwAh",
      "title": "Fix ReadMe correctly :-)",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/15",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-06T21:40:09Z",
      "updatedAt": "2025-02-10T00:42:27Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "ac66462fbfbaeba3a662927e5a23806378d5fd7a",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "more-move-stuff",
      "headRefOid": "0241c04a3e5e71632cf66bd469181dfdf71a6c2f",
      "closedAt": "2025-02-06T21:40:24Z",
      "mergedAt": "2025-02-06T21:40:24Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "c7bdbc2e9b1939f55c1c1d13745b00880fef7a21"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOMBStD86KrVtH",
      "title": "Move example section and make corrections to the example itself",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/16",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I'm also fixing URLs in README.md.",
      "createdAt": "2025-02-10T16:47:42Z",
      "updatedAt": "2025-02-10T18:26:19Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "455d1eeaaa6e69497d9371738ff9030abe8d4a35",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "checkexample",
      "headRefOid": "a632e18f1a13db025e665034d1db5cf776adbb9f",
      "closedAt": "2025-02-10T17:26:17Z",
      "mergedAt": "2025-02-10T17:26:17Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "720587e8d5ae8315877f36fb06da2879139557c5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOMBStD86Kuall",
      "title": "Last minute corrections before 2025-02 interim meeting",
      "url": "https://github.com/ietf-wg-avtcore/sdp-roq/pull/17",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-10T23:10:36Z",
      "updatedAt": "2025-02-10T23:10:36Z",
      "baseRepository": "ietf-wg-avtcore/sdp-roq",
      "baseRefName": "main",
      "baseRefOid": "6a7c9b408dd0b5827a719eb14be82abef7bd3ee5",
      "headRepository": "ietf-wg-avtcore/sdp-roq",
      "headRefName": "pre-interim",
      "headRefOid": "9e0cd23e7aae92da225794ebf0350bce070d05c4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}